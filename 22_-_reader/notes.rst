********************
 Chapter 22: Reader
********************


22.1 Reader
-----------

.. Paragraph 2.

   a) When writing applications, programmers
      often need to pass around some information
      that may be needed intermittently or
      universally throughtout an entire
      application.

      * Ok, so things like envionment variables,
        config file directives, the os type, etc.

   b) We don't want to simply pass this
      information as arguments, because it
      would be present in the type of almost
      every function.

      * When you say "pass this information as
        arguments", what do you have in mind?

        Do you mean passing all of the
        information as a single argument, such
        as a named record containing all
        name:value pairs you may want to
        access (an environment)?

        Or do you mean passing each possible
        config option individually; where each
        option has a separate argument that
        functions must accept using appropriate
        parameters, respectively?

        Or maybe something else?

      * Can you show an example of what this
        would look like?
      * Why not use another approach like:

        * A top-level definition; or
        * a closure (an enclosing scope that
          contains any names you may wish to
          access), possibly generated by a
          function, like the JS function
          factory pattern, Python decerators;
          or
        * an expression imported from a module.

   c) This can make the code harder to read and
      harder to maintain.

      * How does having explicit arguments
        make the code harder to read?
      * Wouldn't it be easier to read, since
        you know what data the functions
        depend on?
      * Can you show an example of what you
        have in mind?

.. The Reader monad effectively creates a
   global read-only value of a specified type.
   All functions within the monad can "read"
   the type. ~ https://mmhaskell.com/blog/2017/
   2/20/how-to-read-and-write-with-monads

.. The phrase "dependency injection" keeps on
   coming up. What is that?

In this chapter, we will:

* examine the ``Functor``, ``Applicative``, and ``Monad``
  type class instances for *functions*;
* learn about the ``Reader`` newtype;
* and see some examples of using ``Reader``.


22.2 A new beginning
--------------------
Here is a recording of me following
along with the section.

.. raw:: html

   <script id="asciicast-he9wsyPdZlIvZ0eSw9XJ3wXDe"
    src="https://asciinema.org/a/he9wsyPdZlIvZ0eSw9XJ3wXDe.js"
    async></script>


.. paragraph 5

``fmap`` applies functions to each element
within a structure. Some of these structures
make intuitive sense, like lists. But, did you
know you can also ``fmap`` over a function?

In the case of ``fmap``'ping over a function,
what is the structure, and what are the
elements that we operate on within that
structure?

.. paragraph 6

Answer: The structure is a partially applied
function, and the elements are the arguments
to that function.

.. paragraph 28

   So, we've seen here that we can have a
   ``Functor``, ``Applicative``, anad
   ``Monad`` for partially applied functions.

   The ``Functor`` of functions is function
   composition.

   The ``Applicative`` and ``Monad`` chain the
   argment forward in addition to the
   composition.

   * What does that mean? What does "chaining
     the argumetn forward" mean? How is that
     different from composition? I would
     assume that they are the same thing.

.. pragraph 29

   Reader is a way of stringing fuctions
   together when all those functions are
   awaiting one input from a shared
   environment.

   We use this most often when we have a
   constant value that we will obtain from
   somewhere outside our program that will be
   an argument to a whole bunch of functions.
