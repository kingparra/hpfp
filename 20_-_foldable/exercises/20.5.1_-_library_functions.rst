20.5.1 Exercises: Library Functions
-----------------------------------
Implement the functions in terms of ``foldMap`` or ``foldr``
from ``Foldable``, then try them out with multiple types
that have ``Foldable`` instances.

1. This and the next one are nicer with ``foldMap``, but
   ``foldr`` is fine, too. ``sum :: (Foldable t, Num a) => t
   a -> a``
2. ``product :: (Foldable t, Num a) => t a -> a``
3. ``elem :: (Foldable t, Eq a) => a -> t a -> Bool``
4. ``minimum :: (Foldable t, Ord a) => t a -> Maybe a``
5. ``maximum :: (Foldable t, Ord a) => t a -> Maybe a``
6. ``null :: (Foldable t) => t a -> Bool``
7. ``length :: (Foldable t) => t a -> Int``
8. Some say this is all ``Foldable`` amounts to.
   ``toList :: (Foldable t) => t a -> [a]``
9. Hint: use ``foldMap``.

   ::

     -- | Combine the elements of a structure using a monoid.
     fold :: (Foldable t, Monoid m) => t m -> m

10. Define ``foldMap`` in terms of ``foldr``. ``foldMap ::
    (Foldable t, Monoid m) => (a -> m) -> t a -> m``

   .. include:: exercises/20.5.1_-_library_functions.rst.d/library-functions/src/Lib.hs
      :start-after: -- Question 10
      :code:

