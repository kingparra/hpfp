#!/usr/bin/env expect

log_user 0
spawn stack exec -- ghci -v0
log_user 1

expect "·∾"; send -- "-- 9.8.2 Spines are evaluated independently of values\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p1. Values in Haskell get reduced to weak head normal\n"
expect "·∾"; send -- "--     form by default. Normal form means fully reduced.\n"
expect "·∾"; send -- "--     Weak head normal form means reduced only as far\n"
expect "·∾"; send -- "--     as necessary to reach a data constructor.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "--     Maybe it would be better to say reach the outermost\n"
expect "·∾"; send -- "--     data constructor, instead.\n"
expect "·∾"; send -- "--\n"
expect "·∾"; send -- "--     To determine if something is in WHNF we only have\n"
expect "·∾"; send -- "--     to look at the outermost part of the expression.\n"
expect "·∾"; send -- "--     If it's a data constructor or lambda, it's in WHNF.\n"
expect "·∾"; send -- "--     If it's a function application, it's not.\n"
expect "·∾"; send "\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p2. WHNF is a larger set and contains both the possibi\n"
expect "·∾"; send -- "--     -lity that the expresion is fully evaluated (NF),\n"
expect "·∾"; send -- "--     and the possibility that the expression has been\n"
expect "·∾"; send -- "--     evaluated to the point of arriving at a data cons\n"
expect "·∾"; send -- "--     -tructor or lambda awaiting an argument.\n"
expect "·∾"; send -- "--     For an expression in WHNF further evaluation may\n"
expect "·∾"; send -- "--     be possible once another argument is provided.\n"
expect "·∾"; send -- "--     If no further inputs are possible, then it is still\n"
expect "·∾"; send -- "--     in WHNF but also in NF.\n"
expect "·∾"; send "\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p3. Below, we list some expressions and whether they are\n"
expect "·∾"; send -- "--     in WHNF, NF, both, or neither:\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- Figure 1, page 321\n"
expect "·∾"; send -- "-- (1,2) -- WHNF & NF\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p4. This first example is in NF and fully evaluted. Any\n"
expect "·∾"; send -- "--     -thing in NF is by definition also in WHNF, because\n"
expect "·∾"; send -- "--     WHNF is an expression that is evaluted up to *at\n"
expect "·∾"; send -- "--     least* the first data constructor. NF exceeds that\n"
expect "·∾"; send -- "--     by requiring that all subexpressions be fully evalu\n"
expect "·∾"; send -- "--     -ated.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p10. This is in WHNF because only the first two ele-\n"
expect "·∾"; send -- "--      -ments were forced. NF would mean that all ele-\n"
expect "·∾"; send -- "--      -ments are forced, and fully reduced.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p11. In these tree representations, evaluation or con\n"
expect "·∾"; send -- "--      -sumption of the list goes down the spine.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- Figure 8 goes here.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p12.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p13. Functions that are spine strict can force compl-\n"
expect "·∾"; send -- "--      -ete evaluation of the spine of a list even if they\n"
expect "·∾"; send -- "--     don't force evaluation of each value. Pattern match-\n"
expect "·∾"; send -- "--     -ing is strict by default, so pattern matching on\n"
expect "·∾"; send -- "--     cons cells can mean forcing spine strictness if your\n"
expect "·∾"; send -- "--     function doesn't stop recursing the list. It can eav-\n"
expect "·∾"; send -- "--     -luate the spine only or the spine as well as the\n"
expect "·∾"; send -- "--     values that inhabit each cons cell, depending on the\n"
expect "·∾"; send -- "--     context.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p14. On the other hand, length is strict in the spine\n"
expect "·∾"; send -- "--      but not the values. If we define a list such as\n"
expect "·∾"; send -- "--      \[1,2\], using length on it would force evaluation\n"
expect "·∾"; send -- "--      of the entire *spine* without accompanying strict\n"
expect "·∾"; send -- "--      -ness in the *values*.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- Figure 9 goes here. I don't feel like typing ascii art.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p15. We can see this if we use length but make one of\n"
expect "·∾"; send -- "--      the values undefined. Since it doesn't visit the\n"
expect "·∾"; send -- "--      values, it won't blow up.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- Figure 9, page 323\n"
expect "·∾"; send -- "x = \[1,undefined\]\n"
expect "·∾"; send -- "length x\n"
expect "2"
expect "·∾"; send -- "-- Notice that there wasn't an exception!\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p16. We could define our own length function:\n"
expect "·∾"; send "\n"
expect "·∾"; send -- ":{\n"
expect " ⋮"; send -- "length' :: \[a\] -> Integer\n"
expect " ⋮"; send -- "length' \[\] = 0\n"
expect " ⋮"; send -- "length' (_:xs) = 1 + length' xs\n"
expect " ⋮"; send -- ":}\n"
expect "·∾"; send -- "\n"
expect "·∾"; send -- "-- p17. We pattern match on the : data constructor but ig\n"
expect "·∾"; send -- "--      -nore the first value.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p18. We're only forcing the : constructor and the \[\] at\n"
expect "·∾"; send -- "--      the end in order to count the number of values.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- Figure 12 goes here, but I'm too lazy to type it!\n"
expect "·∾"; send -- "-- p19. However, length will throw an error on a bottom\n"
expect "·∾"; send -- "--      value if part of the spine itself is bottom:\n"
expect "·∾"; send -- "-- Figure 13\n"
expect "·∾"; send -- "x = \[1\] ++ undefined ++ \[3\]\n"
expect "·∾"; send -- "x\n"
# [1*** Exception: Prelude.undefined
# CallStack (from HasCallStack):
#   error, called at libraries/base/GHC/Err.hs:80:14 in base:GHC.Err
#   undefined, called at <interactive>:19:12 in interactive:Ghci2
expect "·∾"; send -- "length' x\n"
expect "·∾"; send -- "-- p19. However, length will throw an error on a bottom\n"
expect "·∾"; send -- "--      value if part of the spine itself is bottom:\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- Figure 13\n"
expect "·∾"; send -- "x = \[1\] ++ undefined ++ \[3\]\n"
expect "·∾"; send -- "x\n"
# [1*** Exception: Prelude.undefined
# CallStack (from HasCallStack):
#   error, called at libraries/base/GHC/Err.hs:80:14 in base:GHC.Err
#   undefined, called at <interactive>:19:12 in interactive:Ghci2
expect "·∾"; send -- "length' x\n"
# *** Exception: Prelude.undefined
# CallStack (from HasCallStack):
#   error, called at libraries/base/GHC/Err.hs:80:14 in base:GHC.Err
#   undefined, called at <interactive>:19:12 in interactive:Ghci2

expect "·∾"; send -- "-- p20. Printing the list fails, but it gets as far as\n"
expect "·∾"; send -- "--      the first \[1**, and attempting to get the length\n"
expect "·∾"; send -- "--      also fails, because it can't count undefined spine\n"
expect "·∾"; send -- "--      values.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p21. sum is an example of a function that forces both\n"
expect "·∾"; send -- "--      the spine and the values, because in order to\n"
expect "·∾"; send -- "--      return a value at all, it must return the sum of\n"
expect "·∾"; send -- "--      all the values in the list.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p22. We'll write our own sum function for the sake of\n"
expect "·∾"; send -- "--      demonstration.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- Figure 14, page 324\n"
expect "·∾"; send -- ":{\n"
expect " ⋮"; send -- "mySum :: Num a => \[a\] -> a\n"
expect " ⋮"; send -- "mySum \[\] = 0\n"
expect " ⋮"; send -- "mySum (x:xs) = x + mySum xs\n"
expect " ⋮"; send -- ":}\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p23. (+) is strict in both its arguments, so that will\n"
expect "·∾"; send -- "--      force evaluation of the values and the mySum xs.\n"
expect "·∾"; send -- "--      Therefore mySum will keep recursing until it hits\n"
expect "·∾"; send -- "--      the empty list and must stop. Then it will start\n"
expect "·∾"; send -- "--      going back up the spine of the list, summing the\n"
expect "·∾"; send -- "--      inhavitants as it goes.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- Figure 15 goes here.\n"
expect "·∾"; send "\n"
expect "·∾"; send -- "-- p24. We'll return to the topic of Haskell's evaluation\n"
expect "·∾"; send -- "--      strategy at various points in the book. It's a\n"
expect "·∾"; send -- "--      complex topic, and it's better to approach it in\n"
expect "·∾"; send -- "--      stages.\n"
expect "·∾"; send "\n"
