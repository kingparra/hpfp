******************
 Chapter 9: Lists
******************


9.1 Lists
---------


9.2 The list datatype
---------------------
::

  --    The binary infix data constructor (:), used to
  --  construct nested cells of a list, pronounced "cons".
  --  Cons is right associative, and has a precedence of 5,
  --   which is lower than the default of precedence of 9
  --     for regular left associative prefix functions.
  --               vvvvvvv
  data [] a = [] | a : [a]
  --          ^^
  --  The empty list data constructor, [], pronounced "nill".
  --
  -- Since the [] type constructor only takes one type argument,
  -- a, lists must be homogenous in Haskell.
  --
  -- Because of non-strict evaluation, lists can be infinite, and
  -- are often used similarly to iterators generated by range()
  -- in python.

  instance Eq   a => Eq          [a]
  instance Ord  a => Ord         [a]
  instance Show a => Show        [a]
  instance Read a => Read        [a]
  instance           Semigroup   [a]
  instance           Monoid      [a]  -- Depends on Semigroup.
  instance           Foldable    []   -- (foldMap) depends on Monoid.
  instance           Functor     []
  instance           Traversable []   -- Depends on Functor and Foldable.
  instance           Applicative []   -- Depends on Functor.
  instance           Monad       []   -- Depends on Applicative.
  instance           MonadFail   []   -- Depends on Monad.

.. from Will Kurts book: "If you get stuck on a topic
   in Haskell, it's almost always helpful to turn back
   to lists to see if they can give you some insight.


9.3 Pattern matching on lists
-----------------------------

9.3.1 Using Maybe
^^^^^^^^^^^^^^^^^


9.4 List's syntactic sugar
--------------------------


9.5 Using ranges to construct lists
-----------------------------------

.. include:: exercises/9.5.1_-_enumfromto.rst


9.6 Extracting portions of lists
--------------------------------

.. include:: exercises/9.6.1_-_thy_fearful_symmetry.rst


9.7 List comprehensions
-----------------------

.. topic:: From the 2010 Haskell Language Report

   ::

     aexp -> [ exp | qual₁, ... qualₙ ] (list comprehension, n ≥ 1)
     qual -> pat <- exp                 (generator)
           | let decls                  (local declaration)
           | exp                        (boolean guard)

   A list comprehension has the form
   :math:`[ e | q_{1}, ... q_{n} ], n \geq 1`,
   where the :math:`q_{i}` qualifiers are either:

   * *generators* of the form :math:`p \leftarrow e`,
     where :math:`p` is a pattern of type :math:`t`
     and :math:`e` is an expression of type ``[t]``

   * *local bindings* that provide new definitions for
     us in the generated expression :math:`e` or
     subsequent boolean guards or generators.

   * *boolean guards*, where are arbitrary expressions
     of type ``Bool``.

   Such a list comprehension returns the list of
   elements produced by evaluating e in the successive
   environments created by the nested, depth-first
   evaluation of the generators in the qualifier list.
   Binding of variables occurs according to the normal
   pattern matching rules, and if a match fails then
   that element of the list is simply skipped over.

   ::

     ·∾ [ x |
      ⋮   xs    <- [[(1,2),(3,4)],[(5,4),(3,2)]]
      ⋮ , (3,x) <- xs
      ⋮ ]
     [4,2]

   If a qualifier is a boolean guard, it must evalute
   to ``True`` for the previous pattern match to
   succeed. As usual, in bindings in list comprehensions
   can shadow those in outer scopes; for example:

   ``[ x | x <- x, x <- x ]`` ≡ ``[ z | y <- x, z <- y]``

   Variables bound by ``let`` have fully polymorphic
   types while those defined by ``<-`` are lambda
   bound and are thus monomorphic.

9.7.1 Adding predicates
^^^^^^^^^^^^^^^^^^^^^^^

.. include:: exercises/9.7.2_-_comprehend_thy_lists.rst

9.7.3 List comprehensions with strings
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. include:: exercises/9.7.4_-_square_cube.rst


9.8 Spines and nonstrict evaluation
-----------------------------------
The spine is the connective structure that links a
composite data-structure together. In the case of a
list, it's the succession of nested cons data
constructors (and the final empty list data
constructor), like so: ``_ : _ : _ : []``.

Lists aren't constructed until they're consumed.

Also, functions can traverse the spine of a list
without forcing evaluation of the values within
that list.

Another way of phrasing this is: You can evaluate
the cons data constructors in a spine without
forcing evaluation of the arguments to those
constructors.

9.8.1 Using GHCi's :sprint command
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

9.8.2 Spines are evaluated independently of values
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Values in Haskell get reduced to weak head normal
form by default.

Weak head normal form means the expression is only
evaluated as far as is necessary to reach a data
constructor or a lambda awaiting an argument.

**To determine if something is in WHNF we only have
to look at the outermost part of the expression.
If it's a data constructor or lambda, it's in
WHNF. If it's a function application, it's not.**

Evaluation of the list goes "down the spine" (left to
right). Construction of the lists goes "up the spine"
(right to left).

Functions that are spine strict can force complete
evaluation of the spine of a list even if they don't
force evaluation of each value.

.. include:: exercises/9.8.3_-_bottom_madness.rst


9.9 Transforming lists of values
--------------------------------
Map doesn't traverse the whole list and apply the function immediately.
The function is applied to the values you force out of the list one by one.

.. include:: exercises/9.9.1_-_more_bottoms.rst


9.10 Filtering lists of values
------------------------------

.. include:: exercises/9.10.1_-_filtering.rst


9.11 Zipping lists
------------------

.. include:: exercises/9.11.1_-_zipping_exercises.rst


9.12 Chapter Exercises
----------------------

.. include:: exercises/9.12.1_-_Data.Char.rst

.. include:: exercises/9.12.2_-_ciphers.rst

.. include:: exercises/9.12.3_-_writing_your_own_standard_functions.rst
