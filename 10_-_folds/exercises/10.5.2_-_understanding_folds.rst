10.5.2 Exercises: Understanding folds
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. CHAPTER 10. DATA STRUCTURE ORIGAMI 365

.. What would an ideal solution to these multiple-choice problems look like?
   Guess, rationale, test, analysis of test results, button to reproduce test, revision of rationale.

1. ``foldr (*) 1 [1..5]`` Will return the same result as which of the following?

   a) ``flip (*) 1 [1..5]``

      This isn't equivalent to ``foldr (*) [1..5]``. There isn't even
      a fold involved. Let's see what happens when I run it, anyways.

      ::

        ·∾ :set -XFlexibleContexts
        ·∾ flip (*) 1 [1,2,3,4,5]
        <interactive>:5:1: error:
            • No instance for (Num [Integer]) arising from a use of ‘ it’
            • In the first argument of ‘print’, namely ‘it’
              In a stmt of an interactive GHCi command: print it

      We get a type error.

      The evaluation process for this expression should be similar to this:

      ::

        -- flip (*) 1 [1,2,3,4,5]
        -- (\f x y -> y `f` x) (*) 1 [1,2,3,4,5]
        -- (\x y -> y * x) 1 [1,2,3,4,5]
        -- (\y -> y * 1) [1,2,3,4,5]
        -- [1,2,3,4,5] * 1

      Now let's look at the type signature for ``(*)``.

      ::

        ·∾ :type (*)
        (*) :: Num a => a -> a -> a

      As you can see, ``(*)`` requires two arguments.
      Each of its argument must be of the same type, ``a``.
      The type of each argument must also have an instance of the typeclass ``Num``.

      If we run ``[1,2,3,4,5] * 1`` we get an error,
      because the types of ``[1,2,3,4,5]`` and ``1`` are not the same,
      and there is no instance of the ``(*)`` function in ``Num`` that
      operates on an entire list of numbers at once
      ``[1,2,3,4,5] :: Num a => [a]``.

      ::

         ·∾ [1,2,3,4,5] * 1
         <interactive>:1:1: error:
             • Non type-variable argument in the constraint: Num [a]
               (Use FlexibleContexts to permit this)
             • When checking the inferred type
                 it :: forall a. (Num a, Num [a]) => [a]

      I found this error message hard to read, so I asked about it on IRC.

          **justsomguy** I have this expression ``[1,2,3,4,5] * 1``.
          Since the ``*`` function takes two arguments of the same
          type, and ``[1,2,3,4,5]`` and ``1`` have different types, I
          get a type error.  The error is ``Non type-variable argument
          in the constraint: Num [a]``.  I understand the "non
          type-variable argument" part, but what's this about a
          constraint?

          **geekosaur** ``:t (*)``

          **lambdabot** ``Num a => a -> a -> a``

          **geekosaur** Basically, instead of simply failing it as
          incompatible types, ghc tries to promote ``1`` (numeric
          literals are wrapped in ``fromInteger`` or ``fromRational``
          by the compiler) to the type of the other parameter.

          But then hits that error unless you turn on
          ``-XFlexibleContexts`` and then would hit the nonexistence of
          a ``Num`` instance for lists by default.

          ``Num`` is involved twice: once as a constraint on the type
          of ``(*)``, and a second time as a constraint on the type of
          ``fromInteger``

          **geekosaur**  ``:t fromInteger``

          **lambdabot**  ``Num a => Integer -> a``

          **geekosaur** The behavior of numeric literals and the
          ``Num`` instance are documented in the Language Report;
          it's not a ghc-specific thing.
          https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
          and various links from that.

      If I use concrete types for the arguments to ``*``,
      instead of leaving GHC to infer the types,
      the type mismatch error is more obvious.

      ::

        ·∾ ([1,2,3,4,5] :: [Int]) * (1 :: Int)

        <interactive>:9:27: error:
            • Couldn't match expected type ‘[Int]’ with actual type ‘Int’
            • In the second argument of ‘(*)’, namely ‘(1 :: Int)’
              In the expression: ([1, 2, 3, 4, 5] :: [Int]) * (1 :: Int)
              In an equation for ‘it’:
                  it = ([1, 2, 3, 4, ....] :: [Int]) * (1 :: Int)

   b) **foldl (flip (*)) 1 [1..5]**

      The evaluation is parenthesized differently, but
      because the result of ``x * y`` is equivalent to
      ``y * x``, this expression also produces ``120``.

      Parenthesization

      ::

        f x y = "(" ++ x ++ "*" ++ y ++ ")"
        foldr    f     "i" ["1","2","3","4","5"]  ==>  "(1*(2*(3*(4*(5*i)))))"
        foldl    f     "i" ["1","2","3","4","5"]  ==>  "(((((i*1)*2)*3)*4)*5)"
        foldl (flip f) "i" ["1","2","3","4","5"]  ==>  "(5*(4*(3*(2*(1*i)))))"

      Result in GHCi::

        ·∾ foldl (flip (*)) 1 [1,2,3,4,5]
        120

   c) **foldl (*) 1 [1..5]**

      Yes, this is equivalent.
      Here's proof:

      ::

         ·∾ foldr (*) 1 [1..5]
         120

         ·∾ foldl (flip (*)) 1 [1..5]
         120

         ·∾ foldl (*) 1 [1..5]
         120

2. Write out the evaluation steps for ``foldl (flip (*)) 1 [1..3]``:

   |  foldl :: (b -> a -> b) -> b -> [a] -> b
   |  foldl f acc l =
   |    case l of
   |     [] -> acc
   |     (x:xs) -> foldl f (f acc x) xs
   |
   |  foldl (flip (*)) 1 [1,2,3] =
   |    case [1,2,3] of
   |     [] -> 1
   |     (1:[2,3]) ->
   |       foldl (flip (*)) **((flip (*)) acc 1)** [2,3] =
   |         case [2,3] of
   |           [] -> 1
   |           (2:[3]) ->
   |             foldl (flip (*)) **((flip (*)) ((flip (*)) acc 1) 2)** [3] =
   |               case [3] of
   |                 [] -> 1
   |                 (3:[]) ->
   |                     foldl (flip (*)) **((flip (*)) ((flip (*)) ((flip (*)) acc 1) 2) 3)** [] =
   |                       case [] of
   |                         [] -> **1**
   |

   The fully accumulated expression looks like this...


   **((flip (*)) ((flip (*)) ((flip (*)) 1 1) 2) 3)**

   If we write our function infix, the association is easier to see

   | let
   |   f = flip (*)
   | in
   |   ((((1 \`f` 1) \`f` 2) \`f` 3)

   We can reduce this to normal form, now, if we want...

   |     ((flip (*)) ((flip (*)) ((flip (*)) 1 1) 2) 3)
   |                    ((flip (*)) ((flip (*)) 1 2) 3)
   |                                   ((flip (*)) 2 3)
   |                                                 6

3. One difference between ``foldr`` and ``foldl`` is:

   a) ``foldr``, but not ``foldl``, traverses the spine of a list from right to left.

      False. Both functions traverse the spine in the same direction.

      10.4.1 How foldr evaluates, paragraph 17, says:

        17a) **One initially non-obvious aspect of folding is that it happens in two stages, traversal and folding.**
        17b) **Traversal is the stage in which the fold recurses over the spine.**
        17c) **Folding refers to the evaluation or reduction of the folding function applied to the values.**
        17d) **All folds recurse over the spine in the same direction;
        the difference between left folds and right folds
        is in the association, or parenthesization, of the folding function
        and, thus, in which direction the folding or reduction proceeds.**


      10.5 Fold left, paragraph 1, sentence b says:

        1b) **Left folds traverse the spine in the same direction as right folds, but their folding
        process is left associative and proceeds in the opposite direction as that of ``foldr``.**

      From 10.5.1 Associativity and folding:

      1b) **As we've said, both folds traverse the spine in the
      same direction.**

      3d) **Right folds have to traverse the list outside-in, but
      the folding itself starts from the end of the list.**

      How do I *prove* this is true, though?
      Can I create an experiment that demonstrates this to be true?
      What about an argument from the function definition?

   b) ``foldr``, but not ``foldl``, always forces the rest of the fold.

      This is false.
      Here is a counter-example.

      ::

        ·∾ foldr (\_ _ -> 9001) 0 [1..]
        9001

      The values ``2:3:4:n`` are not evaluated.

   c) **foldr, but not foldl, associates to the right.**

      Yes, here's proof!

      ::

        ·∾  f x y = "(" ++ x ++ "*" ++ y ++ ")"

        ·∾  foldr f "1" ["1","2","3","4","5"]
        "(1*(2*(3*(4*(5*1)))))"

        ·∾  foldl f "1" ["1","2","3","4","5"]
        "(((((1*1)*2)*3)*4)*5)"

   d) ``foldr``, but not ``foldl``, is recursive.

      No. Both functions must be recursive in order to traverse the spine of the list.

4. Folds are catamorphisms, which means they are generally used to:

   a) **Reduce structure.**
   b) Expand structure.
   c) Render you catatonic.
   d) Generate infinite data structures.

5. The following are simple folds very similar to what you've already seen,
   but each has at least one error. Please fix and test them in your REPL:

   a) ``foldr (++) ["woot", "WOOT", "woot"]``

      ::

        ·∾ foldr (++) ["woot","WOOT","woot"]
        <interactive>:1:1: error:
            • No instance for (Show ([[String]] -> [String]))
                arising from a use of ‘print’
                (maybe you haven't applied a function to enough argumens?)
            • In a stmt of an interactive GHCi command: print it

        ·∾ -- This fold was missing an identity value

        ·∾ foldr (++) "" ["woot","WOOT","woot"]
        "wootWOOTwoot"

   b) ``foldr max [] "fear is the little death"``

      The function ``max`` will try to produce the character with the smallest ordinal value.
      But the accumulator parameter is set to the empty list, ``[]``, instead of a character.
      So there will be a type error.

      ::

          ·∾ foldr max [] "fear is the little death"

          <interactive>:1:14: error:
              • Couldn't match type ‘Char’ with ‘[a]’
                Expected type: [[a]]
                  Actual type: [Char]
              • In the third argument of ‘foldr’, namely
                  ‘"fear is the little death"’
                In the expression: foldr max [] "fear is the little death"
                In an equation for ‘it’:
                    it = foldr max [] "fear is the little death"
              • Relevant bindings include it :: [a] (bound at <interactive>:1:1)

      In order to fix this, we should make the accumulator a character.
      I've picked the char with the lowest ordinal value so it doesn't become the result.

      ::

         ·∾ foldr max (minBound :: Char) "fear is the little death"
         't'

   c) ``foldr and True [False, True]``

      I don't remember what ``and`` does, let me look it up.

      ::

        ·∾ :type and
        and :: Foldable t => t Bool -> Bool

      So it takes a collection of bools and returns a bool.
      ``bool`` only takes one argument, but the input function to
      ``foldr`` must be of two arguments.  So this won't work.

      ::

         ·∾ foldr and True [False,True]

         <interactive>:14:7: error:
             • Couldn't match type ‘Bool’ with ‘Bool -> Bool’
               Expected type: t0 Bool -> Bool -> Bool
                 Actual type: t0 Bool -> Bool
             • In the first argument of ‘foldr’, namely ‘and’
               In the expression: foldr and True [False, True]
               In an equation for ‘it’: it = foldr and True [False, True]

         <interactive>:14:17: error:
             • Couldn't match expected type ‘t0 Bool’ with actual type ‘Bool’
             • In the expression: False
               In the third argument of ‘foldr’, namely ‘[False, True]’
               In the expression: foldr and True [False, True]

         <interactive>:14:23: error:
             • Couldn't match expected type ‘t0 Bool’ with actual type ‘Bool’
             • In the expression: True
               In the third argument of ‘foldr’, namely ‘[False, True]’
               In the expression: foldr and True [False, True]

      So, I'll write a new input function that takes two arguments, instead.

      ::

        ·∾ foldr (\x y -> x && y) True [False,True]
        False

   d) This one is more subtle than the previous.

      ::

        foldr (||) True [False, True]

      Can it ever return a different answer?

      This function will always return True,
      since the z value is True,
      and ``((||) False True)`` returns True.

      ::

        ·∾ foldr (||) True [False,True]
        True
        ·∾ foldr (||) True [False,False,False]
        True
        ·∾ foldr (||) True [True,True,True]
        True

      If we change the z value to False, then it's possible for
      this expression to return False, given the right input
      list.

      ::

        ·∾ foldr (||) False [True,True,True]
        True
        ·∾ foldr (||) False [True,True,False]
        True
        ·∾ foldr (||) False [False,False,False]
        False

   e) ``foldl ((++) . show) "" [1..5]``

       The arguments to our input function are reversed.
       Using ``foldr`` instead of ``foldl`` will have the intended effect.

       ::

          ·∾ foldl ((++) . show) "" [1,2,3,4,5]
          <interactive>:31:25: error:
              • No instance for (Num [Char]) arising from the literal ‘1’
              • In the expression: 1
                In the third argument of ‘foldl’, namely ‘[1, 2, 3, 4, ....]’
                In the expression: foldl ((++) . show) "" [1, 2, 3, 4, ....]

          ·∾ ((++) . show) "" [1,2,3,4]
          <interactive>:33:19: error:
              • No instance for (Num Char) arising from the literal ‘1’
              • In the expression: 1
                In the second argument of ‘(++) . show’, namely ‘[1, 2, 3, 4]’
                In the expression: ((++) . show) "" [1, 2, 3, 4]

          ·∾ ((++) . show) [1,2,3,4] ""
          "[1,2,3,4]"

          ·∾ foldr ((++) . show) "" [1,2,3,4,5]
          "12345"

          ·∾ foldl (flip ((++) . show)) "" [1,2,3,4,5]
          "54321"

   f) ``foldr const 'a' [1..5]``

      The type signature of ``foldr`` is...

      ::

        foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

      The ``b`` type variable is determined by the argument value we
      supply to our ``z`` parameter, ``'a'``.


      The value ``'a'`` is a character.

      ::

        ·∾ :type 'a'
        'a' :: Char

      Therefore, the input function bound to ``f`` must return a
      character.

      But the first argument to our input function ``const`` is the
      first element of the list, ``1``.

      The full expression would be
      ``const 1 (const 2 (const 3 (const 4 (const 5 'a'))))``.

      ``const`` always returns its first argument.

      The return value of ``1 :: Num a => a`` does not match the
      expected return type of ``Char``. So we get a type error
      when GHC tries to infer a type that is both a ``Char``,
      and has an instance of ``Num``.

      ::

        ·∾ foldr const 'a' [1,2,3,4,5]

        <interactive>:52:18: error:
            • No instance for (Num Char) arising from the literal ‘1’
            • In the expression: 1
              In the third argument of ‘foldr’, namely ‘[1, 2, 3, 4, ....]’
              In the expression: foldr const 'a' [1, 2, 3, 4, ....]

      To fix this, we can change the ``'a'`` to ``0``.

      ::

        ·∾ foldr const 0 [1,2,3,4,5]
        1

      Or we can flip const, so that it receives ``'a'`` as it's first argument.

      ::

        ·∾ foldr (flip const) 'a' [1,2,3,4,5]
        'a'

      Which evaluates like this

      ::

        (flip const)
          1
          ((flip const) 2 ((flip const) 3 ((flip const) 4 ((flip const) 5 'a' ))))

        (flip const)
          1
          ((flip const) 2 ((flip const) 3 ((flip const) 4 'a')))

        (flip const)
          1
          ((flip const) 2 ((flip const) 3 'a'))

        (flip const)
          1
          ((flip const) 2 'a')

        (flip const) 1 'a'

        'a'


   g) ``foldr const 0 "tacos"``

     Let's look at the type signature for foldr again.

     ::

       ·∾ :type foldr
        foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

     Now I'll examine the types of each argument.

     ::

        ·∾ :type const
        const :: a -> b -> a

        ·∾ :type 0
        0 :: Num p => p

        ·∾ :type "tacos"
        "tacos" :: [Char]

     If I plug in the types to foldr's type signature by hand, I get this.

     ::

       foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

       -- First I'll line it up

       foldr const 0 "tacos" ::     const :: (a -> b -> a)
                             ->         0 :: Num b => b
                             ->   "tacos" :: [Char]

       -- Now I'll plug in the types so that all occurences of them are substituted in
       -- a ~ Char
       -- b ~ Num b => b
       -- Foldable t => t ~ []
       foldr const 0 "tacos" ::
         Num b
         =>  (b -> Char -> b)
         ->  b
         ->  [Char]

     So looking at this type signature, ``const`` *must* return a
     ``Num a => a``.  The second argument to ``const`` must also
     be a ``Char``.  But the accumulator, which serves as the
     second argument to ``const``, is a ``Char``, instead.

     So I should get a type error when I run this, that tells me
     that ``Char`` does not have an instance of the ``Num``
     typeclass. Let me try.

     ::

       ·∾ :type foldr const 0 "tacos"

       <interactive>:1:13: error:
           • No instance for (Num Char) arising from the literal ‘0’
           • In the second argument of ‘foldr’, namely ‘0’
             In the expression: foldr const 0 "tacos"
            value

    So now we have two options: implement an instance of
    ``Num`` for ``Char``, or we can ``flip const``.

    ::

      ·∾ foldr (flip const) 0 "tacos"
      0

   h) ``foldl (flip const) 0 "burritos"``

      Now we need to unflip const :)

      ::

        ·∾ foldl (flip const) 0 "burritos"

        <interactive>:31:20: error:
            • No instance for (Num Char) arising from the literal ‘0’
            • In the second argument of ‘foldl’, namely ‘0’
              In the expression: foldl (flip const) 0 "burritos"
              In an equation for ‘it’: it = foldl (flip const) 0 "burritos"
        ·∾ foldl const 0 "burritos"
        0

   i) ``foldl (flip const) 'z' [1..5]``

      ::

        ·∾ foldl (flip const) 'z' [1..5]
        <interactive>:34:25: error:
            • No instance for (Num Char) arising from the literal ‘1’
            • In the expression: 1
              In the third argument of ‘foldl’, namely ‘[1 .. 5]’
              In the expression: foldl (flip const) 'z' [1 .. 5]
        ·∾ foldl const 'z' [1..5]
        'z'

.. CHAPTER 10. DATA STRUCTURE ORIGAMI 366
