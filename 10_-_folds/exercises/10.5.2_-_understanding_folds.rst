10.5.2 Exercises: Understanding folds
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. CHAPTER 10. DATA STRUCTURE ORIGAMI 365

.. What would an ideal solution to these multiple-choice problems look like?
   guess, rationale, test, analysis of test results, button to reproduce test, revision of rationale

1. ``foldr (*) 1 [1..5]`` Will return the same result as which of the following?

   a) ``flip (*) 1 [1..5]``

      This isn't equivalent.
      There isn't even a fold involved.
      Let's see what happens when I run it, anyways.

      ::

        ·∾ :set -XFlexibleContexts
        ·∾ flip (*) 1 [1,2,3,4,5]
        <interactive>:5:1: error:
            • No instance for (Num [Integer]) arising from a use of ‘ it’
            • In the first argument of ‘print’, namely ‘it’
              In a stmt of an interactive GHCi command: print it

      We get a type error.
      The desugared expressions looks like this.

      ::

        -- flip (*) 1 [1,2,3,4,5]
        -- (\f x y -> y `f` x) (*) 1 [1,2,3,4,5]
        -- (\x y -> y * x) 1 [1,2,3,4,5]
        -- (\y -> y * 1) [1,2,3,4,5]
        -- [1,2,3,4,5] * 1

      Now let's look at the type signature for ``(*)``.

      ::

        ·∾ :type (*)
        (*) :: Num a => a -> a -> a

      As you can see, ``(*)`` requires two arguments.
      Each argument must be of the same type, ``a``.
      The type of each argument must also have an instance of the typeclass ``Num``.

      If we run ``[1,2,3,4,5] * 1`` we get an error,
      because the types of ``[1,2,3,4,5]`` and ``1``
      are not the same.

      ::

         ·∾ [1,2,3,4,5] * 1
         <interactive>:1:1: error:
             • Non type-variable argument in the constraint: Num [a]
               (Use FlexibleContexts to permit this)
             • When checking the inferred type
                 it :: forall a. (Num a, Num [a]) => [a]

      I found this error message hard to read, so I asked about it on IRC.

        ``justsomguy`` |

        I have this expression [1,2,3,4,5] * 1.
        Since the * function takes two arguments of the same type, and [1,2,3,4,5] and 1 have different types, I get a type error.
        The error is Non type-variable argument in the constraint: Num [a].
        I understand the "non type-variable argument" part, but what's this about a constraint?

        ``geekosaur`` | :t (*)
        ``lambdabot`` | Num a => a -> a -> a

        ``geekosaur`` |

        **Basically, instead of simply failing it as incompatible types,
        ghc tries to promote 1
        (numeric literals are wrapped in fromInteger or fromRational by the compiler)
        to the type of the other parameter.**

        But then hits that error unless you turn on
        FlexibleContexts and then would hit the nonexistence
        of a Num instance for lists by default.

        Num is involved twice: once as a constraint on the
        type of (*), and a second time as a constraint on
        the type of fromInteger

        ``geekosaur`` | :t fromInteger
        ``lambdabot`` | Num a => Integer -> a

        The behavior of numeric literals and the Num
        instance are documented in the Language Report;
        it's not a ghc-specific thing.
        https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
        and various links from that.

      If I use concrete types for the arguments to ``*``,
      instead of leaving GHC to infer the types,
      the type mismatch error is easier to read.

      ::

        ·∾ ([1,2,3,4,5] :: [Int]) * (1 :: Int)

        <interactive>:9:27: error:
            • Couldn't match expected type ‘[Int]’ with actual type ‘Int’
            • In the second argument of ‘(*)’, namely ‘(1 :: Int)’
              In the expression: ([1, 2, 3, 4, 5] :: [Int]) * (1 :: Int)
              In an equation for ‘it’:
                  it = ([1, 2, 3, 4, ....] :: [Int]) * (1 :: Int)


   b) **foldl (flip (*)) 1 [1..5]**

      The evaluation is parenthesized differently, but
      because the result of ``x * y`` is equivalent to
      ``y * x``, this expression also produces ``120``.

      Parenthesization

      ::

        f x y = "(" ++ x ++ "*" ++ y ++ ")"
        foldr    f     "i" ["1","2","3","4","5"]  ==>  "(1*(2*(3*(4*(5*i)))))"
        foldl    f     "i" ["1","2","3","4","5"]  ==>  "(((((i*1)*2)*3)*4)*5)"
        foldl (flip f) "i" ["1","2","3","4","5"]  ==>  "(5*(4*(3*(2*(1*i)))))"

      Result in GHCi::

        ·∾ foldl (flip (*)) 1 [1,2,3,4,5]
        120

   c) **foldl (*) 1 [1..5]**

      Yes, this is equivalent.
      Here's proof:

      ::

         ·∾ foldr (*) 1 [1..5]
         120

         ·∾ foldl (flip (*)) 1 [1..5]
         120

         ·∾ foldl (*) 1 [1..5]
         120

2. Write out the evaluation steps for::

     foldl (flip (*)) 1 [1..3]

     foldl (flip (*)) 1 [1,2,3]

     foldl (\x y -> y * x) 1 [1,2,3]

     foldl :: (b -> a -> b) -> b [a] -> b
     foldl f acc [] = acc
     foldl f acc (x:xs) = foldl f (f acc x) xs

     foldl f acc (x:xs) =
       foldl f (f acc x) xs

     foldl (\x y -> y*x) 1 (1:[2,3]) =
       foldl
         (\x y -> y*x)
         ((\x y -> y*x) 1 1)
         [2,3]

     foldl (\x y -> y*x) ((\x y -> y*x) 1 1) (2:[3]) =
       foldl
         (\x y -> y*x)
         ((\x y -> y*x) ((\x y -> y*x) 1 1) 2)
         [3]

     foldl (\x y -> y*x) ((\x y -> y*x) ((\x y -> y*x) 1 1) 2) (3:[]) =
       foldl
         (\x y -> y*x)
         ((\x y -> y*x) ((\x y -> y*x) ((\x y -> y*x) 1 1) 2) 3)
         []

     The base case for [] is triggered

     foldl (\x y -> y*x) ((\x y -> y*x) ((\x y -> y*x) ((\x y -> y*x) 1 1) 2) 3) [] =
         ((\x y -> y*x) ((\x y -> y*x) ((\x y -> y*x) 1 1) 2) 3)

     So we are left with...

     ( (\x y -> y*x) ((\x y -> y*x) ((\x y -> y*x) 1 1) 2) 3)

     outermost reduction, parameter binding and head elimination are one step

     ((\x y -> y*x)
      ((\x y -> y*x) ((\x y -> y*x) 1 1) 2)
      3)

     ((\y -> y*((\x y -> y*x) ((\x y -> y*x) 1 1) 2))
      3)

     3*((\x y -> y*x)
        ((\x y -> y*x) 1 1)
        2)

     3*((\y -> y*((\x y -> y*x) 1 1))
        2)

     3*(2*(
       (\x y -> y*x)
       1
       1))

     3*(2*(
      (\y -> y*1)
      1)))

     3*(2*(1*1))

     3*(2*1)

     3*2

     6

3. One difference between ``foldr`` and ``foldl`` is:

   a) ``foldr``, but not ``foldl``, traverses the spine of a list from right to left.

      False. Both functions traverse the spine in the same direction.

      10.4.1 How foldr evaluates, paragraph 17, says:

        17a) **One initially non-obvious aspect of folding is that it happens in two stages, traversal and folding.**
        17b) **Traversal is the stage in which the fold recurses over the spine.**
        17c) **Folding refers to the evaluation or reduction of the folding function applied to the values.**
        17d) **All folds recurse over the spine in the same direction;
        the difference between left folds and right folds
        is in the association, or parenthesization, of the folding function
        and, thus, in which direction the folding or reduction proceeds.**


      10.5 Fold left, paragraph 1, sentence b says:

        1b) **Left folds traverse the spine in the same direction as right folds, but their folding
        process is left associative and proceeds in the opposite direction as that of ``foldr``.**

      How do I *prove* this is true, though?
      Can I create an experiment that demonstrates this to be true?
      What about an argument from the function definition?

   b) ``foldr``, but not ``foldl``, always forces the rest of the fold.

      This is false.
      Here is a counter-example.

      ::

        ·∾ foldr (\_ _ -> 9001) 0 [1..]
        9001

      The values ``2:3:4:n`` are not evaluated.

   c) **foldr, but not foldl, associates to the right.**

      Yes, here's proof!

      ::

        ·∾  f x y = "(" ++ x ++ "*" ++ y ++ ")"

        ·∾  foldr f "1" ["1","2","3","4","5"]
        "(1*(2*(3*(4*(5*1)))))"

        ·∾  foldl f "1" ["1","2","3","4","5"]
        "(((((1*1)*2)*3)*4)*5)"

   d) ``foldr``, but not ``foldl``, is recursive.

      No. Both functions must be recursive in order to traverse the spine of the list.

4. Folds are catamorphisms, which means they are generally used to:

   a) **Reduce structure.**
   b) Expand structure.
   c) Render you catatonic.
   d) Generate infinite data structures.

5. The following are simple folds very similar to what you've already seen,
   but each has at least one error.
   Please fix and test them in your REPL:

   a) ``foldr (++) ["woot", "WOOT", "woot"]``

      ::

        ·∾ foldr (++) ["woot","WOOT","woot"]
        <interactive>:1:1: error:
            • No instance for (Show ([[String]] -> [String]))
                arising from a use of ‘print’
                (maybe you haven't applied a function to enough argumens?)
            • In a stmt of an interactive GHCi command: print it

        ·∾ -- This fold was missing an identity value

        ·∾ foldr (++) "" ["woot","WOOT","woot"]
        "wootWOOTwoot"

   b) ``foldr max [] "fear is the little death"``

      The function ``max`` will try to produce the character with the smallest ordinal value.
      But the accumulator parameter is set to the empty list, ``[]``, instead of a character.
      So there will be a type error.

      ::

          ·∾ foldr max [] "fear is the little death"

          <interactive>:1:14: error:
              • Couldn't match type ‘Char’ with ‘[a]’
                Expected type: [[a]]
                  Actual type: [Char]
              • In the third argument of ‘foldr’, namely
                  ‘"fear is the little death"’
                In the expression: foldr max [] "fear is the little death"
                In an equation for ‘it’:
                    it = foldr max [] "fear is the little death"
              • Relevant bindings include it :: [a] (bound at <interactive>:1:1)

      In order to fix this, we should make the accumulator a character.
      I've picked the char with the lowest ordinal value so it doesn't become the result.

      ::

         ·∾ foldr max (minBound :: Char) "fear is the little death"
         't'

   c) ``foldr and True [False, True]``

      I don't remember what ``and`` does, let me look it up.

      ::

        ·∾ :type and
        and :: Foldable t => t Bool -> Bool

      So it takes a collection of bools and returns a bool.
      ``bool`` only takes one argument, but the input function to ``foldr`` must be of two arguments.
      So this won't work.

      ::

         ·∾ foldr and True [False,True]

         <interactive>:14:7: error:
             • Couldn't match type ‘Bool’ with ‘Bool -> Bool’
               Expected type: t0 Bool -> Bool -> Bool
                 Actual type: t0 Bool -> Bool
             • In the first argument of ‘foldr’, namely ‘and’
               In the expression: foldr and True [False, True]
               In an equation for ‘it’: it = foldr and True [False, True]

         <interactive>:14:17: error:
             • Couldn't match expected type ‘t0 Bool’ with actual type ‘Bool’
             • In the expression: False
               In the third argument of ‘foldr’, namely ‘[False, True]’
               In the expression: foldr and True [False, True]

         <interactive>:14:23: error:
             • Couldn't match expected type ‘t0 Bool’ with actual type ‘Bool’
             • In the expression: True
               In the third argument of ‘foldr’, namely ‘[False, True]’
               In the expression: foldr and True [False, True]

      So, I'll write a new input function that takes two arguments, instead.

      ::

        ·∾ foldr (\x y -> x && y) True [False,True]
        False

   d) This one is more subtle than the previous.

      ::

        foldr (||) True [False, True]

      Can it ever return a different answer?

      This function will always return True,
      since the z value is True,
      and ``((||) False True)`` returns True.

      ::

        ·∾ foldr (||) True [False,True]
        True
        ·∾ foldr (||) True [False,False,False]
        True
        ·∾ foldr (||) True [True,True,True]
        True

      If we change the z value to False, then it's possible for this expression to return False,
      given the right input list.

      ::

        ·∾ foldr (||) False [True,True,True]
        True
        ·∾ foldr (||) False [True,True,False]
        True
        ·∾ foldr (||) False [False,False,False]
        False

   e) ``foldl ((++) . show) "" [1..5]``

       The arguments to our input function are reversed.
       Using ``foldr`` instead of ``foldl`` will have the intended effect.

       ::

          ·∾ foldl ((++) . show) "" [1,2,3,4,5]
          <interactive>:31:25: error:
              • No instance for (Num [Char]) arising from the literal ‘1’
              • In the expression: 1
                In the third argument of ‘foldl’, namely ‘[1, 2, 3, 4, ....]’
                In the expression: foldl ((++) . show) "" [1, 2, 3, 4, ....]

          ·∾ ((++) . show) "" [1,2,3,4]
          <interactive>:33:19: error:
              • No instance for (Num Char) arising from the literal ‘1’
              • In the expression: 1
                In the second argument of ‘(++) . show’, namely ‘[1, 2, 3, 4]’
                In the expression: ((++) . show) "" [1, 2, 3, 4]

          ·∾ ((++) . show) [1,2,3,4] ""
          "[1,2,3,4]"

          ·∾ foldr ((++) . show) "" [1,2,3,4,5]
          "12345"

          ·∾ foldl (flip ((++) . show)) "" [1,2,3,4,5]
          "54321"

   f) ``foldr const 'a' [1..5]``

      The type signature of ``foldr`` is...

      ::

        foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

      The ``b`` type variable is determined by the argument value we
      supply to our ``z`` parameter, ``'a'``.


      The value ``'a'`` is a character.

      ::

        ·∾ :type 'a'
        'a' :: Char

      Therefore, the input function bound to ``f`` must return a
      character.

      But the first argument to our input function ``const`` is the
      first element of the list, ``1``.

      The full expression would be
      ``const 1 (const 2 (const 3 (const 4 (const 5 'a'))))``.

      ``const`` always returns its first argument.

      The return value of ``1 :: Num a => a`` does not match the
      expected return type of ``Char``. So we get a type error
      when GHC tries to infer a type that is both a ``Char``,
      and has an instance of ``Num``.

      ::

        ·∾ foldr const 'a' [1,2,3,4,5]

        <interactive>:52:18: error:
            • No instance for (Num Char) arising from the literal ‘1’
            • In the expression: 1
              In the third argument of ‘foldr’, namely ‘[1, 2, 3, 4, ....]’
              In the expression: foldr const 'a' [1, 2, 3, 4, ....]

      To fix this, we can change the ``'a'`` to ``0``.

      ::

        ·∾ foldr const 0 [1,2,3,4,5]
        1

      Or we can flip const, so that it receives ``'a'`` as it's first argument.

      ::

        ·∾ foldr (flip const) 'a' [1,2,3,4,5]
        'a'

      Which evaluates like this

      ::

        (flip const)
          1
          ((flip const) 2 ((flip const) 3 ((flip const) 4 ((flip const) 5 'a' ))))

        (flip const)
          1
          ((flip const) 2 ((flip const) 3 ((flip const) 4 'a')))

        (flip const)
          1
          ((flip const) 2 ((flip const) 3 'a'))

        (flip const)
          1
          ((flip const) 2 'a')

        (flip const) 1 'a'

        'a'


   g) ``foldr const 0 "tacos"``
   h) ``foldl (flip const) 0 "burritos"``
   i) ``foldl (flip const) 'z' [1..5]``

.. CHAPTER 10. DATA STRUCTURE ORIGAMI 366
